### 思路一

观察到旋转数组的特点: **在任意位置将其分割为两段后, `target`只可能在一段中出现, 并且至少有一段是单调上升的**, 因此使用二分查找时, 可以先识别出单调上升那一段, 而后用该段的左右端点判断`target`是否可能处于单调上升段, 从而决定下一步的搜索区间. 上述思路兑现为如下:

```cpp
class Solution {
public:
	int search(vector<int>& nums, int target) {
		int left = 0, right = nums.size(), mid;
		while(left < right){
			mid = left + (right - left) / 2;
			if (target == nums[mid])
				return mid;
			if (nums[left] <= nums[mid]) { // 判断[left, mid]为单调上升段, <=可以改为<
				if (target < nums[mid] && target >= nums[left]) left = mid + 1;
				else right = mid;
			}
			else { // 否则[mid, right)必为单调上升段
				if (target > nums[mid] && target <= nums[right - 1]) left = mid + 1;
				else right = mid;
			}
		}
		return -1;
	}
}
```

### 思路二

首先找出旋转点(最小值点), 保证左右两段均为单调上升序列, 使用`nums[nums.size()-1]`判断target的可能位置. 接下来利用二分查找进行

寻找最小值代码可参考leetcode 153题. 按此思路完整代码如下(复杂度应该在常数因子上高于思路一):

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n = nums.size();
        int idx = findMin(nums);
        if (target <= nums[n - 1])
            return bsearch(nums, target, idx, n);
        else
            return bsearch(nums, target, 0, idx);
    }
private:
    int findMin(vector<int>& nums) {
        int n = nums.size();
        int left = 0, right = n, mid;
        while (left < right) {
            if (nums[left] <= nums[right-1])
                return left;
            mid = left + (right - left) / 2;
            if (nums[mid] < nums[mid - 1])
                return mid;
            if (nums[left] <= nums[mid])
                left = mid + 1;
            else
                right = mid;
        }
        return -1;
    }

    int bsearch(vector<int> const &nums, int target, int i, int j) {
        int mid;
        while (i < j) {
            mid = i + (j - i) / 2;
            if (nums[mid] == target) return mid;
            if (nums[mid] < target) i = mid + 1;
            else j = mid;
        }
        return -1;
    }
};
```

